import { DesignSystemVersion } from '../../core/SDKDesignSystemVersion';
import { TokenGroup } from '../../model/groups/SDKTokenGroup';
import { Token } from '../../model/tokens/SDKToken';
import { DTProcessedTokenNode } from './utilities/SDKDTJSONConverter';
import { Brand } from '../../core/SDKBrand';
import { TokenTheme } from '../../model/themes/SDKTokenTheme';
import { DTPluginToSupernovaMapPack, DTPluginToSupernovaSettings } from './utilities/SDKDTMapLoader';
export declare type SupernovaToolsDesignTokensLoadingResult = {
    processedNodes: Array<DTProcessedTokenNode>;
    tokens: Array<Token>;
    groups: Array<TokenGroup>;
};
/** Design Tokens Plugin Manipulation Tool */
export declare class SupernovaToolsDesignTokensPlugin {
    private version;
    private sortMultiplier;
    constructor(version: DesignSystemVersion);
    /** Synchronizes tokens with specified version of design system using all JSONs in a specific directory. Will load mapping configuration from the provided mapping file path as well. */
    synchronizeTokensFromDirectory(directoryPath: string, mappingPath: string): Promise<boolean>;
    /** Synchronizes tokens with specified version of design system from the tokens file provided. Will load mapping configuration from the provided mapping file path as well. */
    synchronizeTokensFromFile(filePath: string, mappingPath: string): Promise<boolean>;
    synchronizeTokensFromData(data: object, mapping: DTPluginToSupernovaMapPack, settings: DTPluginToSupernovaSettings): Promise<boolean>;
    private processTokenNodes;
    /** Loads remote source connected to this tool, then merges tokens and groups with it, creating union. Can optionally write to the source as well */
    mergeWithRemoteSource(processedNodes: Array<DTProcessedTokenNode>, brand: Brand, write: boolean, verbose: boolean, preciseCopy: boolean): Promise<{
        tokens: Array<Token>;
        groups: Array<TokenGroup>;
    }>;
    /** Loads remote source connected to this tool, then creates the diff from the base tree and updates the associated theme. Can optionally write to the source as well */
    mergeThemeWithRemoteSource(processedNodes: Array<DTProcessedTokenNode>, brand: Brand, theme: TokenTheme, write: boolean, verbose: boolean): Promise<{
        theme: TokenTheme;
    }>;
    correctSortOrder(tokens: Array<Token>, tokenGroups: Array<TokenGroup>): void;
    correctSortOrderFromTypeRoot(root: TokenGroup, tokenMap: Map<string, Token>, groupMap: Map<string, TokenGroup>): void;
    flattenedIdsFromRoot(root: TokenGroup, tokenMap: Map<string, Token>, groupMap: Map<string, TokenGroup>): Array<string>;
}
